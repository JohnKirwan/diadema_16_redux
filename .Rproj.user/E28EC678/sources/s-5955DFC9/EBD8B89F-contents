---
title: "Ophiocoma Spatial Resolution and Contrast Sensitivity"
author: "John D. Kirwan"
date: '2019-08-17'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(mc.cores = parallel::detectCores())  # run all cores
Sys.setenv(LOCAL_CPPFLAGS = '-march=native') # for faster Stan execution 
```

Load necessary packages. 

```{r Load packages, message=FALSE, warning=TRUE}
library('magrittr')
library('readr')
library('dplyr')
library('purrr')
library('tibble')
library('circular')
library('ggplot2')
library('reshape2')
library('circular')
library('bayesplot')
library('rethinking')
rstan::rstan_options(auto_write = TRUE)
library('brms')
```

Load the data. The column *target* refers to the target of the stimulus at each observation; radian and degree are the headings taken by the animal from the centre in radians and degrees respectively. Batch refers to animals collected and tested in either 2018 or 2019. Load the data and make into radians from -pi to pi. We represent the stimulus period and target half width angles in radians rather than degrees because the smaller (but still positive) values for the model predictor are preferable.  


```{r}
df <- read_delim('tenerife-june-2016.txt', delim = '\t')
```

Plot response to a very wide stimulus (90 degree). Then remove these from the dataset.

```{r}
plot.circular(df$theta[df$unmissable==1])
df <- df[df$unmissable==0,]
df$unmissable <- NULL 
```

No obvious response from the few data available.

```{r}

```


Below are the different treatments of target size and contrast with the number of observations indicated by the size of the black dot.

```{r}
df %>% group_by(dog) %>%
  ggplot(aes(arc,color=dog)) + geom_histogram()
```

```{r}
plot.circular(df$theta)
```


### Discretization

Here, we define the sector of the circle which we consider to be the 'target' region.

```{r}
df %>% mutate(success = 0) -> df
for(i in 1:length(df$theta)){           ### get tote of each using one fifth of the circle
  if(is.na(df$theta[i]) == TRUE) {df$success[i] <- 0}
  else if( df$theta[i] >   pi/4) {df$success[i] <- 0}    ## pi/5 beforehand
  else if( df$theta[i] <= -pi/4 ){df$success[i] <- 0}  ## -pi/5 beforehand
  else{    df$success[i] <- 1}  }
```

Make dataframe for the contrast experiment and the resolution experiment. Each include the 0$&deg;$ negative control with no stimulus.



Have a look at what happens with differing Type width of the target, to get an impression of the response and to see if the result is likely to be robust to changes in the Type width.

```{r Treatment summary, message=TRUE, warning=FALSE}
df %>% as_tibble %>%                 # dataframe name
  mutate(in.quad = ifelse(abs(theta) < pi/4, 1, 0)) %>% # for data in radians -pi to pi
  mutate(in.pent = ifelse(abs(theta) < pi/5, 1, 0)) %>% # for data in radians -pi to pi
  mutate(in.sext = ifelse(abs(theta) < pi/6, 1, 0)) %>% # for data in radians -pi to pi
  mutate(in.oct  = ifelse(abs(theta) < pi/8, 1, 0)) %>% # for data in radians -pi to pi
  group_by(arc,dog) %>%                # condition name
  summarize(target = round(arc * 180 / pi)[1],
            n_obs = n(),                 
            mu    = round(180*mean.circular(theta)/pi,0),
            lo.ci = round(180*mle.vonmises.bootstrap.ci(theta)$mu.ci[1]/pi),
            hi.ci = round(180*mle.vonmises.bootstrap.ci(theta)$mu.ci[2]/pi),
            rho = round(rho.circular(theta),2),
            kappa = unlist(mle.vonmises(theta)[3]), 
            v.stat =unlist(rayleigh.test(theta,mu=0)[1]),
            v.p= unlist(rayleigh.test(theta,mu=0)[2]),
            rayl.stat=unlist(rayleigh.test(theta)[1]),
            rayl.p= unlist(rayleigh.test(theta)[2]),
            c.mean = unlist(mean.circular(theta)[1]),
            quad.prop = sum(in.quad)/length(in.quad),
            pent.prop = sum(in.pent)/length(in.pent),
            sext.prop = sum(in.sext)/length(in.sext),
            oct.prop = sum(in.oct)/length(in.oct),
            binom.p6 = unlist(
                binom.test(sum(in.sext),length(in.sext),
                p=1/6,alternative = "greater")[3]),
            binom.p8 = unlist(
                binom.test(sum(in.oct),length(in.oct),
                p=1/8,alternative = "greater")[3]),
            binom.p5 = unlist(
                binom.test(sum(in.pent),length(in.pent),
                p=1/5,alternative = "greater")[3])) -> circ_fun_facts
## output dataframe
circ_fun_facts
```

# Resolution

```{r Res Circular plots, message=FALSE}
res$T <- round(res$target / max(res$target),2)
d2r <- function(x){ x <- x*pi/180 } # turn degrees to radians
vonMisease <- function(x){if(x > pi){x <- x-2*pi};return(x)}
vonMapease <- function(x){modify(x,vonMisease)}
res %>% mutate(H = d2r(heading)) -> res
res %>% mutate(H = unlist(vonMapease(H))) -> res # make headings in rad

res %>% mutate(success = 0) -> res
for(i in 1:length(res$H)){           ### get tote of each using one fifth of the circle
  if(is.na(res$H[i]) == TRUE) {res$success[i] <- 0}
  else if( res$H[i] >   pi/6) {res$success[i] <- 0}    ## pi/5 beforehand
  else if( res$H[i] <= -pi/6 ){res$success[i] <- 0}  ## -pi/5 beforehand
  else{    res$success[i] <- 1}  }
```


Make dataframe for the contrast experiment and the resolution experiment. Each include the 0$&deg;$ negative control with no stimulus.

### Plot the headings

Below, we make circular plots of the vectors for each of the treatments. Code borrowed and modified from James J. Foster (University of Würzburg).

The confidence interval in these plots represents confidence intervals from bootstrapped maximum likelihood (in contrast to Sumner-Rooney *et al* (2020) where they represent circular standard deviation).


```{r Contrast circular plots, message=FALSE}
source('Cplot2_rad.R')
par(mfrow = c(2,ceiling( nlevels(as.factor(res$T)) /2)));  
par(mar = c(0.5, 0.5, 0.5, 0.5) + 0.1) # bottom, left, top, right
for(i in levels(as.factor(res$T)) ){
    rad_plot(res$H[res$T==i],0.06)
 }
```


Have a look at what happens with differing Type width of the target, to get an impression of the response and to see if the result is likely to be robust to changes in the Type width.

```{r Resolution treatment summary, message=TRUE, warning=FALSE}
res %>% as_tibble %>%                 # dataframe name
  mutate(in.quad = ifelse(abs(H) < pi/4, 1, 0)) %>% # for data in radians -pi to pi
  mutate(in.pent = ifelse(abs(H) < pi/5, 1, 0)) %>% # for data in radians -pi to pi
  mutate(in.sext = ifelse(abs(H) < pi/6, 1, 0)) %>% # for data in radians -pi to pi
  mutate(in.oct  = ifelse(abs(H) < pi/8, 1, 0)) %>% # for data in radians -pi to pi
  group_by(T) %>%                # condition name
  summarize(target = round(T * 180 / pi)[1],
            n_obs = n(),                 
            mu    = round(180*mean.circular(H)/pi,0),
            lo.ci = round(180*mle.vonmises.bootstrap.ci(H)$mu.ci[1]/pi),
            hi.ci = round(180*mle.vonmises.bootstrap.ci(H)$mu.ci[2]/pi),
            rho = round(rho.circular(H),2),
            kappa = unlist(mle.vonmises(H)[3]), 
            v.stat =unlist(rayleigh.test(H,mu=0)[1]),
            v.p= unlist(rayleigh.test(H,mu=0)[2]),
            rayl.stat=unlist(rayleigh.test(H)[1]),
            rayl.p= unlist(rayleigh.test(H)[2]),
            c.mean = unlist(mean.circular(H)[1]),
            quad.prop = sum(in.quad)/length(in.quad),
            pent.prop = sum(in.pent)/length(in.pent),
            sext.prop = sum(in.sext)/length(in.sext),
            oct.prop = sum(in.oct)/length(in.oct),
            binom.p6 = unlist(
                binom.test(sum(in.sext),length(in.sext),
                p=1/6,alternative = "greater")[3]),
            binom.p8 = unlist(
                binom.test(sum(in.oct),length(in.oct),
                p=1/8,alternative = "greater")[3]),
            binom.p5 = unlist(
                binom.test(sum(in.pent),length(in.pent),
                p=1/5,alternative = "greater")[3])) -> circ_fun_res
## output dataframe
circ_fun_res
```


```{r}
circ_fun_res %>% 
  ggplot(aes(180*T/pi, sext.prop)) + geom_line(color="pink",size=3)  + 
  ylab("Proportion correct responses") +
  theme_classic() + xlab("Stimulus period") +  ## data in target quadrant
  geom_line(aes(y=oct.prop), color="red")   +    ## data in target octant
  geom_line(aes(y=quad.prop), color="blue")    +    ## data in target octant
   geom_line(data=circ_fun_res,aes(x=180*T/pi , y=pent.prop),size=1) + 
   geom_hline(yintercept = 1/6) +
   geom_bin2d(data=res,aes(y = success, x = 180*T/pi)) + # counts 
   ylim(0.1,0.55)
```

### Try with new formulation

We tried a fair few versions of the model. We settled on this version because it includes both upper and lower asymptotes and was able to converge. 4.39 approximates 2 x ln(1 - 1 / alpha), which scales the width parameter. Here alpha = 0.1, 10%, which scales width so that threshold ± width/2 includes the x axis region in which the curve rises from 10% of its maximum height above guess rate to 90% of its maximum height above guess rate. 

The following non-default priors were given to brms. An informative prior was used for the lower asymptote (base) as this value should not differ much from 0.2. Upper and lower bounds were used for the aysmptotes to prevent overlap, which would make the model unidentifiable.  

This is the (exponentiated) prior applied to width of the psychometric curve between 10% and 90% of its maximum height and the model threshold.

### Prior Predictive Distribution for Resolution

Below, we plot the possible range of values deemed by the priors and where predictions are distributed. A stimulus with the maximal target used (70 degrees) is already extremmely wide. We know the base should be at 0.167 by random chance - so we put the location of the base parameter prior at this value, but allow it to vary around this point. Constraints are placed on base and lapse to prevent them overlappping. Priors on threshold and width keep these parameters within the possible range of angles. The inverse logit (logistic) function is *plogis* in base.

From previous data, we know the response rate of this species to a salient stimulus is within the range 0.3 to 0.8.

```{r}
set.seed(196)
N          <- 100
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability 
lapse      <- rbeta(N,15,15)       # Lapse is wide range - should not overlap base rate
threshold  <- rgamma(N,2,2)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,2)    # Width must be > 0 and can be > 1.
                                   # Varying intercept lapse
                                   # Varying intercepts base

plot( NULL, xlim = c(-.5,3.5), ylim = c(0.1,0.8) , 
      xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
        base[i] + 
          (1 - base[i] - lapse[i]) * 
          plogis(4.39*(	x - threshold[i]	)	/ ( (width[i]) ) ),
   from=-.5, to = 3.5, add = TRUE, col = col.alpha("black",0.1))

```

### *Empty* model without predictor


```{r Empty model}
res.empty.formula <- bf(success ~ 
                      base + 
                      (1 - base - lapse) * 
                      inv_logit( 4.39*(	1 - threshold)	/  width  ),
  base      ~ 1,# + (1|individual), # guess rate has a single value
	lapse     ~ 1, #+ (1|individual), # lapse rate can be different for different chicks
	threshold ~ 1, #+ (1|individual), # threshold changes with all effects
	width     ~ 1, #+ (1|individual), # threshold-width changes with all effects
                      nl = TRUE)

res.psych.priors  <- c(
         prior(normal(0.167,0.05),   nlpar = "base",        lb=0,ub= 0.25),               
         prior(beta(15,15),          nlpar = "lapse"             ,lb=0,ub= 0.74      ), 
         prior(gamma(2,2),         nlpar= 'threshold',  class = 'b'   ),
	       prior(gamma(2,2),         nlpar = 'width',     class = 'b'     ))

res_empty_fit  <- brm(res.empty.formula, data = res, family = bernoulli("identity"), iter = 5000,
              chains = 4, prior = res.psych.priors, control = list(adapt_delta=0.99999)) 

res_empty_fit <- add_criterion(res_empty_fit, c("loo","waic")) 
```

## Main model

```{r Main model}
res.psych.formula <- bf(success ~ 
                      base + 
                      (1 - base - lapse) * 
                      inv_logit( 4.39*(	T - threshold	)	/  width  ),
  base  ~ 1, lapse ~ 1, threshold ~ 1, width ~ 1, nl = TRUE)

res.psych.priors  <- c(
         prior(normal(0.167,0.05),   nlpar = "base",        lb=0,ub= 0.25),               
         prior(beta(15,15),            nlpar = "lapse"             ,lb=0,ub= 0.74      ), 
         prior(gamma(2,2),           nlpar= 'threshold',  class = 'b'   ),
	       prior(gamma(2,2),           nlpar = 'width',     class = 'b'     ))

res_psych_fit  <- brm(res.psych.formula, data = res, 
                  family = bernoulli("identity"), iter = 2500,
                  chains = 4, prior = res.psych.priors, 
                  control = list(max_treedepth = 12,
                                 adapt_delta=0.9999999)) 

res_psych_fit  <- add_criterion(res_psych_fit, c("loo","waic")) 
```


```{r}
res %>% group_by(T) %>%
  summarise(p = sum(success)/length(success)) -> props 
props %>%
  ggplot(aes(x=T,y=p,size=p)) + geom_point() + theme_classic()
```

```{r}
conditional_effects(res_psych_fit, spaghetti=T, nsamples = 1000,robust=TRUE)
```


According to the checks below (rhat and ESS) the model fit fine.

```{r}
summary(res_psych_fit)
```

The parameters are unimodal and the chains converged, resembling *hairy catterpillars.* Lapse is skewed, on account of the constraint imposed and because low values are perfectly plausible.

```{r}
plot(res_psych_fit)
```


```{r}
loo_compare(res_psych_fit,res_empty_fit)
```



```{r Extract the samples}
res.psych.smpl <- posterior_samples(res_psych_fit)
```


```{r}
posterior_summary(res_psych_fit, 
                  pars=c("b_base_Intercept", "b_lapse_Intercept", "b_threshold_Intercept","b_width_Intercept"),
                  probs = c(0.025,  0.975), robust = TRUE)
```

Plot the threshold and width transformed.

```{r}
param_trans <- function(x){
  out = x*max(res$target)
  return(out)}
mcmc_areas(res_psych_fit, pars=c("b_threshold_Intercept","b_width_Intercept"),   
         point_est = "median", prob = 0.8, prob_outer = 0.95,
         transformations = param_trans) +
         ggplot2::labs(title = "Posterior distributions", 
                       subtitle = "with medians and 80% intervals")
```

### Confidence intervals of the threshold parameter.

PI (percentile interval) is a confidence interval similar to that conventionally used in frequentist statistics, which assigns equal mass to each tail. 

```{r}
threshold_smpl <- (res.psych.smpl$b_threshold_Intercept)*max(res$target)
round(PI(threshold_smpl,prob=.95),0)
```

HPDI (highest posterior density) is an alternative confidence interval which is especially useful is the distribution is skewed. 

```{r}
round(HPDI(threshold_smpl,prob=.95),0)
```

```{r}
round(HPDI(threshold_smpl,prob=.5),0)
```

### Graphical Posterior predictive checks

Back to the main psychometric model. We check if the posterior predictions are in line with the original counts, which is so.  

```{r}
  pp_check(res_psych_fit,nsamples=400, type="bars",) + theme_classic() + theme(legend.position='none') 
```


```{r}
  pp_check(res_psych_fit, type = "rootogram", nsamples = 100, style = "standing", prob=0.9) +   theme_classic()  
```


```{r}
ggplot(data=circ_fun_res ,aes(x=T , y=sext.prop, size=n_obs)) +
geom_point() + theme_classic() + scale_size_area(max_size = 4) + theme(legend.position="none") + ylim(0,0.7) +
  ylab("Proportion orented towards target sector") + xlab("Stimulus arc width")
```

### Bayes R-squared

```{r}
bayes_R2(res_psych_fit)
```

### Plot each line from the draws and find the inflection point of each

```{r}
N = 70*3*5
vals <- array(dim=c(5000,N))
turn.idx <- vector(length = length(res.psych.smpl[,1]))
x <- seq(from=0,to=3,length.out = N)
newdat <- data.frame(T = T)

plot( NULL, xlim = c(0,3), ylim = c(0.1,.7) , 
      xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
i = 1
for ( i  in 1:length(res.psych.smpl[,1])){

  vals[i,] <- res.psych.smpl$b_base_Intercept[i] + 
          (1 - res.psych.smpl$b_base_Intercept[i] - res.psych.smpl$b_lapse_Intercept[i]) * 
          plogis(4.39*(	x - res.psych.smpl$b_threshold_Intercept[i]	)	/ 
                    (res.psych.smpl$b_width_Intercept[i]) )
  lines(x,vals[i,],col = col.alpha("black",0.02))
  
  #infl[i] <- c(FALSE, diff(diff(vals[i,])>0)!=0)
  #points(xl[infl ], out[infl ], col="blue")
  
  turn.idx[i] <- which.min(diff(diff(diff(vals[i,])))) # get turning point
  }
```

### Turning points

The turning point of the curve corresponds to the threshold (in our interpretation). Above, we extracted the turning point for each iteration.

```{r}
turning.pts <- turn.idx/5
hist(turning.pts,breaks = 100)
```

Below, are two confidence intervals for the turning point. The first works best with symmetrical distributions.

```{r}
round(PI(turning.pts,prob=.95),0)
```

We prefer HPDI because the distribution is not symmetrical.

```{r}
round(HPDI(turning.pts,prob=.95),0)
```

50% credibility interval 

```{r}
round(HPDI(turning.pts,prob=.5),0)
```


Compare to the value of the *threshold* parameter (transformed) for reference: They are not identical. Prefer the turning point estimate above.

```{r}
HPDI(exp(res.psych.smpl$b_threshold_Intercept)*max(res$target))
```

### Categorical model

For completeness, we can include a model with a categorical predictor.

```{r}
res$Tc <- as.factor(res$target)
res.cat <- bf(success ~ Tc, family = bernoulli(link="logit"))

res.cat.prior  <- c(
         prior(normal(0,1),   class = "Intercept"), 
	       prior(normal(0,1),   class = 'b'     )
                   )

res.cat.fit  <- brm(res.cat, data = res, 
                  family = bernoulli("logit"), iter = 2000,
                  chains = 4, prior = res.cat.prior)

res.cat.fit  <- add_criterion(res.cat.fit, c("loo","waic")) 
```


```{r}
conditional_effects(res.cat.fit)
```



# Contrast

Four different levels of Michelson contrast were applied: the grey negative control and three levels of contrast of the 60 degree stimulus (0.05, 0.1, and 1). 

```{r}
con$T <- round(con$target / max(con$target),2)
d2r <- function(x){ x <- x*pi/180 } # turn degrees to radians
vonMisease <- function(x){if(x > pi){x <- x-2*pi};return(x)}
vonMapease <- function(x){modify(x,vonMisease)}
con %>% mutate(H = d2r(heading)) -> con
con %>% mutate(H = unlist(vonMapease(H))) -> con # make headings in rad

con %>% mutate(success = 0) -> con
for(i in 1:length(con$H)){           ### get tote of each using one fifth of the circle
  if(is.na(con$H[i]) == TRUE) {con$success[i] <- 0}
  else if( con$H[i] >   pi/6) {con$success[i] <- 0}    ## pi/5 beforehand
  else if( con$H[i] <= -pi/6 ){con$success[i] <- 0}  ## -pi/5 beforehand
  else{    con$success[i] <- 1}  }
```


Make dataframe for the contrast experiment and the resolution experiment. Each include the 0$&deg;$ negative control with no stimulus.


## Plot of Contrast levels

Below, we make circular plots of the vectors for each of the treatments. Code borrowed and modified from James J. Foster (University of Würzburg).

```{r}
source('Cplot2_rad.R')
par(mfrow = c(2, ceiling(nlevels(as.factor(con$contrast))/2) ));  
par(mar = c(0.5, 0.5, 0.5, 0.5) + 0.1) # bottom, left, top, right
for(i in levels(as.factor(con$contrast)) ){
    rad_plot(con$H[con$contrast==i],0.06)#,
}
```

Have a look at what happens with differing contrast, to get an impression of the response and to see if the result is likely to be robust to changes in contrast.

```{r Contrast treatment summary, message=TRUE, warning=FALSE}
con %>% as_tibble %>%                 # dataframe name
  mutate(in.quad = ifelse(abs(H) < pi/4, 1, 0)) %>% # for data in radians -pi to pi
  mutate(in.pent = ifelse(abs(H) < pi/5, 1, 0)) %>% # for data in radians -pi to pi
  mutate(in.sext = ifelse(abs(H) < pi/6, 1, 0)) %>% # for data in radians -pi to pi
  mutate(in.oct  = ifelse(abs(H) < pi/8, 1, 0)) %>% # for data in radians -pi to pi
  group_by(contrast) %>%                # condition name
  summarize(target = round(T * 180 / pi)[1],
            n_obs = n(),                 
            mu    = round(180*mean.circular(H)/pi,0),
            lo.ci = round(180*mle.vonmises.bootstrap.ci(H)$mu.ci[1]/pi),
            hi.ci = round(180*mle.vonmises.bootstrap.ci(H)$mu.ci[2]/pi),
            rho = round(rho.circular(H),2),
            kappa = unlist(mle.vonmises(H)[3]), 
            v.stat =unlist(rayleigh.test(H,mu=0)[1]),
            v.p= unlist(rayleigh.test(H,mu=0)[2]),
            rayl.stat=unlist(rayleigh.test(H)[1]),
            rayl.p= unlist(rayleigh.test(H)[2]),
            c.mean = unlist(mean.circular(H)[1]),
            quad.prop = sum(in.quad)/length(in.quad),
            pent.prop = sum(in.pent)/length(in.pent),
            sext.prop = sum(in.sext)/length(in.sext),
            oct.prop = sum(in.oct)/length(in.oct),
            binom.p6 = unlist(
                binom.test(sum(in.sext),length(in.sext),
                p=1/6,alternative = "greater")[3]),
            binom.p8 = unlist(
                binom.test(sum(in.oct),length(in.oct),
                p=1/8,alternative = "greater")[3]),
            binom.p5 = unlist(
                binom.test(sum(in.pent),length(in.pent),
                p=1/5,alternative = "greater")[3])) -> circ_fun_con
## output dataframe
circ_fun_con
```


```{r}
circ_fun_con %>% 
  ggplot(aes(contrast, sext.prop)) + geom_line(color="pink",size=3)  + 
  ylab("Proportion correct responses") +
  theme_classic() + xlab("Michelson contrast") +  ## data in target quadrant
  geom_line(aes(y=oct.prop), color="red")   +    ## data in target octant
  geom_line(aes(y=quad.prop), color="blue")    +    ## data in target octant
   geom_line(data=circ_fun_con,aes(x=contrast , y=pent.prop),size=1) + 
   geom_hline(yintercept = 1/6) +
   geom_bin2d(data=con,aes(y = success, x = contrast)) + # counts
   ylim(0.1,0.45)
```


## Prior Predictive Distribution for contrast

The inverse logit (logistic) function is *plogis* in base.

```{r}
set.seed(196)
N          <- 1000
base       <- rnorm(N,0.167,0.05)  # Base is close to random probability 
lapse      <- rbeta(N,15,15)       # Lapse is wide range - should not overlap base rate
threshold  <- rgamma(N,2,3)    # Threshold must be > 0 and can be > 1.
width      <- rgamma(N,2,3)    # Width must be > 0 and can be > 1.
                                   # Varying intercept lapse
                                   # Varying intercepts base

plot( NULL, xlim = c(-.5,1.5), ylim = c(0,1) , 
      xlab = "Scaled stimulus strength", ylab = "Proportion correct response" )
abline (h=1/6, lty=2)
for ( i  in 1:N ) curve (
        base[i] + 
          (1 - base[i] - lapse[i]) * 
          plogis(4.39*(	x - (threshold[i])	)	/ (  (width[i]) ) ),
   from=-.5, to = 1.5, add = TRUE, col = col.alpha("black",0.1))

```


### Contrast psychometric model

State the model and priors.

```{r}
con.psych.formula <- bf(success ~ 
                      base + 
                      (1 - base - lapse) * 
                      inv_logit( 4.39*(	contrast - (threshold)	)	/  (width)  ),
  base      ~ 1,	lapse     ~ 1, threshold ~ 1, width     ~ 1, nl = TRUE)

con.psych.priors  <- c(
         prior(normal(0.167,0.05),   nlpar = "base",        lb=0,ub= 0.25),               
         prior(beta(15,15),      nlpar = "lapse"             ,lb=0,ub= 0.74      ), 
         prior(gamma(2,3),         nlpar= 'threshold',  class = 'b'   ),
	       prior(gamma(2,3),         nlpar = 'width',     class = 'b'     ))
```


Run an *Empty* model without main predictor:

```{r}
con.empty.formula <- bf(success ~ 
                      base + 
                      (1 - base - lapse) * 
                      inv_logit(4.39*(	1 - (threshold)	)	/
                      (  (width) ) ),
  base ~ 1, lapse ~ 1, threshold ~ 1, width ~ 1, nl = TRUE)

con.empty.fit  <- brm(con.empty.formula, data = con, family = bernoulli("identity"), iter = 5000,
              chains = 4, prior = con.psych.priors, control = list(adapt_delta=0.99999))

con.empty.fit <- add_criterion(con.empty.fit, c("loo","waic")) 
```

Run the main model.

```{r}
con.psycho.fit  <- brm(con.psych.formula, data = con, 
                  family = bernoulli("identity"), iter = 2500,
                  chains = 4, prior = con.psych.priors, 
                  control = list(max_treedepth = 12,
                                 adapt_delta=0.99999)) 

con.psycho.fit  <- add_criterion(con.psycho.fit, c("loo","waic")) 
```


```{r}
summary(con.psycho.fit)
```

```{r}
conditional_effects(con.psycho.fit)
```


```{r Plot the draws}
con.smpl <- posterior_samples(con.psycho.fit)
smpl <- mutate(as.data.frame(con.smpl), index = 1:length(lp__))
ggplot(melt(
    dplyr::select(smpl,- starts_with("r_")),
    id.var = "index"), aes(x=index, y=value)) + geom_point(alpha = 0.2, colour = "blue") +
    facet_wrap(~variable, scale = "free_y") + theme_classic()
```


```{r}
post_sum <- posterior_summary(con.psycho.fit, 
                  pars=c(
                    "b_base_Intercept", "b_lapse_Intercept", "b_threshold_Intercept","b_width_Intercept",
                         "sd_individual__lapse_Intercept","sd_individual__threshold_Intercept","sd_individual__width_Intercept"),
                         probs = c(0.025,  0.975), robust = TRUE)
```


Trace and density plots for MCMC samples.

```{r Trace and Density Plots for MCMC samples}
plot(con.psycho.fit)#, N= 7)
```

Plot the threshold and width tranformed into degrees in radians.

```{r}
mcmc_plot(con.psycho.fit, pars=c("b_width_Intercept","b_threshold_Intercept"), type="areas",  
         point_est = "median", prob = 0.8, prob_outer = 0.95, 
         transformations = exp) +
         ggplot2::labs(title = "Posterior distributions", subtitle = "with medians and 80% intervals")
```

Just the threshold

```{r}
mcmc_plot(con.psycho.fit, pars=c("b_threshold_Intercept"), type="areas",  
         point_est = "median", prob = 0.8, prob_outer = 0.95,
         transformations = exp) +
         ggplot2::labs(title = "Posterior distributions", subtitle = "with medians and 95% intervals")
```


```{r}
  pp_check(con.psycho.fit,nsamples=400, type="bars",) + theme_classic() + theme(legend.position='none')
```


```{r}
  pp_check(con.psycho.fit, type = "rootogram", nsamples = 100, style = "standing", prob=0.9) +   theme_classic()  
```


```{r}
ggplot(data=circ_fun_con ,aes(x=contrast , y=sext.prop, size=n_obs)) +
geom_point() + theme_classic() + scale_size_area(max_size = 4) + theme(legend.position="none") + ylim(0,0.7) +
  ylab("Proportion orented towards target sector") + xlab("Stimulus arc width")
```


```{r}
loo_compare(con.psycho.fit,con.empty.fit)
```

The psychometric model could not find estimate the threshold of contrast of a 60 degree target in reasonable bounds (i.e. below a contrast of 1).

### Contrast Categorical variable

We can get an idea of the contrast sensitivity by treating contrast as a categorical variable.

```{r}
con$C  <- as.factor(con$contrast)
con.cat.fit <- bf(success ~ C, family = bernoulli(link="logit"))

con.cat.prior  <- c(
         prior(normal(0,1),   class = "Intercept"), 
	       prior(normal(0,1),   class = 'b'     )
                   )

con.cat.fit  <- brm(con.cat.fit, data = con, 
                  family = bernoulli("logit"), iter = 2000,
                  chains = 4, prior = con.cat.prior)
```


```{r}
conditional_effects(con.cat.fit,robust = T)
```

The estimate of the control (0) without contrast has its median at random and greater levels increase montonically. The estimates of the different levels of contrast overlap extensively but the estimate at the highest level of Michelson contrast (1) is likely greater than random. 

```{r}
con.cat.smpl <- posterior_samples(con.cat.fit)
paste0(round(100*sum(con.cat.smpl$b_C1 > 0.167) / length(con.cat.smpl$b_C1)),"%")
```


